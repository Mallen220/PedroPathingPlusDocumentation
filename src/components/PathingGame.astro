---
---

<div id="game-container" class="game-container">
  <div id="ui-overlay" class="ui-overlay">
    <div id="start-screen">
      <h2>Pathing Challenge</h2>
      <p>Use Arrow Keys to guide the robot.</p>
      <p>Collect artifacts to score points.</p>
      <p>Avoid hitting the walls or other robots!</p>
      <button id="start-btn" class="game-btn">Start Pathing</button>
    </div>
    <div id="game-over-screen" class="hidden">
      <h2>Path Interrupted!</h2>
      <p>Score: <span id="final-score">0</span></p>
      <button id="restart-btn" class="game-btn">Try Again</button>
    </div>
  </div>
  <canvas id="game-canvas" width="600" height="600"></canvas>
  <div class="score-board">Score: <span id="score">0</span></div>
</div>

<style>
  .game-container {
    position: relative;
    width: 100%;
    max-width: 600px;
    margin: 2rem auto;
    border: 2px solid var(--sl-color-accent);
    border-radius: 8px;
    overflow: hidden;
    background-color: var(--sl-color-bg-nav);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }

  canvas {
    display: block;
    width: 100%;
    height: auto;
    background-color: #1a1a1a;
    background-size: cover;
    background-position: center;
  }

  .ui-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.85);
    color: white;
    z-index: 10;
    text-align: center;
  }

  .hidden {
    display: none !important;
  }

  h2 {
    font-size: 2rem;
    margin-bottom: 1rem;
    color: #ff4d4d;
  }

  p {
    margin-bottom: 0.8rem;
    font-size: 1.1rem;
  }

  .game-btn {
    padding: 0.8rem 1.5rem;
    font-size: 1.2rem;
    font-weight: bold;
    color: white;
    background: linear-gradient(45deg, #ff4d4d, #4d4dff);
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: transform 0.2s;
    margin-top: 1rem;
  }

  .game-btn:hover {
    transform: scale(1.05);
  }

  .score-board {
    padding: 0.5rem;
    background-color: var(--sl-color-bg-nav);
    color: var(--sl-color-text);
    text-align: center;
    font-weight: bold;
    font-size: 1.2rem;
    border-top: 1px solid var(--sl-color-gray-5);
  }
</style>

<script>
  // Game Constants
  const CANVAS_WIDTH = 600;
  const CANVAS_HEIGHT = 600;
  const ROBOT_SIZE = 55; // Diameter of robot (Increased from 40)
  const ROBOT_RADIUS = ROBOT_SIZE / 2;
  const ARTIFACT_SIZE = 20;
  const ARTIFACT_RADIUS = ARTIFACT_SIZE / 2;
  const PLAYER_SPEED = 3;
  const ENEMY_SPEED = 2;
  const ENEMY_COUNT = 3;

  // Elements
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  const scoreElement = document.getElementById('score');
  const finalScoreElement = document.getElementById('final-score');
  const startScreen = document.getElementById('start-screen');
  const gameOverScreen = document.getElementById('game-over-screen');
  const uiOverlay = document.getElementById('ui-overlay');
  const startBtn = document.getElementById('start-btn');
  const restartBtn = document.getElementById('restart-btn');

  // Assets
  const robotImg = new Image();
  robotImg.src = '/robot.png';

  const fieldImg = new Image();
  fieldImg.src = '/field.webp';

  // Game State
  let player = { x: 300, y: 300, angle: 0, vx: 0, vy: 0 };
  let artifacts = [];
  let enemies = [];
  let score = 0;
  let animationFrameId;
  let isGameRunning = false;
  let keys = {};

  // Input Handling
  window.addEventListener('keydown', (e) => {
    // Prevent default scrolling for arrow keys
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    keys[e.key] = true;
  });
  window.addEventListener('keyup', (e) => keys[e.key] = false);

  function spawnArtifact() {
    const margin = 50;
    artifacts.push({
      x: margin + Math.random() * (CANVAS_WIDTH - 2 * margin),
      y: margin + Math.random() * (CANVAS_HEIGHT - 2 * margin),
      color: `hsl(${Math.random() * 360}, 70%, 50%)`
    });
  }

  function spawnEnemies() {
    enemies = [];
    for (let i = 0; i < ENEMY_COUNT; i++) {
      enemies.push({
        x: Math.random() * (CANVAS_WIDTH - 100) + 50,
        y: Math.random() * (CANVAS_HEIGHT - 100) + 50,
        vx: (Math.random() - 0.5) * ENEMY_SPEED * 2,
        vy: (Math.random() - 0.5) * ENEMY_SPEED * 2,
        angle: 0
      });
    }
  }

  function initGame() {
    player = { x: 300, y: 300, angle: -Math.PI / 2, vx: 0, vy: 0 };
    score = 0;
    scoreElement.textContent = score;
    artifacts = [];
    spawnArtifact();
    spawnEnemies();

    isGameRunning = true;
    keys = {}; // Reset keys

    // UI
    uiOverlay.classList.add('hidden');
    startScreen.classList.add('hidden');
    gameOverScreen.classList.add('hidden');

    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    gameLoop();
  }

  function update() {
    // Player Movement (Direct Directional)
    let dx = 0;
    let dy = 0;

    if (keys['ArrowUp']) dy = -PLAYER_SPEED;
    if (keys['ArrowDown']) dy = PLAYER_SPEED;
    if (keys['ArrowLeft']) dx = -PLAYER_SPEED;
    if (keys['ArrowRight']) dx = PLAYER_SPEED;

    // Normalize diagonal speed
    if (dx !== 0 && dy !== 0) {
        const factor = 1 / Math.sqrt(2);
        dx *= factor;
        dy *= factor;
    } else if (dx === 0 && dy === 0) {
        // Friction / Stop immediately
    }

    player.x += dx;
    player.y += dy;

    // Rotate player to face movement direction if moving
    if (dx !== 0 || dy !== 0) {
        // Calculate target angle
        const targetAngle = Math.atan2(dy, dx);
        player.angle = targetAngle;
    }

    // Wall Collision (Game Over)
    if (player.x - ROBOT_RADIUS < 0 || player.x + ROBOT_RADIUS > CANVAS_WIDTH ||
        player.y - ROBOT_RADIUS < 0 || player.y + ROBOT_RADIUS > CANVAS_HEIGHT) {
      gameOver();
      return;
    }

    // Artifact Collection
    for (let i = artifacts.length - 1; i >= 0; i--) {
      const a = artifacts[i];
      const dist = Math.hypot(player.x - a.x, player.y - a.y);
      if (dist < ROBOT_RADIUS + ARTIFACT_RADIUS) {
        score++;
        scoreElement.textContent = score;
        artifacts.splice(i, 1);
        spawnArtifact();
      }
    }

    // Enemy Logic
    enemies.forEach(enemy => {
      enemy.x += enemy.vx;
      enemy.y += enemy.vy;

      // Bounce off walls
      if (enemy.x - ROBOT_RADIUS < 0) {
          enemy.x = ROBOT_RADIUS;
          enemy.vx = Math.abs(enemy.vx);
      } else if (enemy.x + ROBOT_RADIUS > CANVAS_WIDTH) {
          enemy.x = CANVAS_WIDTH - ROBOT_RADIUS;
          enemy.vx = -Math.abs(enemy.vx);
      }

      if (enemy.y - ROBOT_RADIUS < 0) {
          enemy.y = ROBOT_RADIUS;
          enemy.vy = Math.abs(enemy.vy);
      } else if (enemy.y + ROBOT_RADIUS > CANVAS_HEIGHT) {
          enemy.y = CANVAS_HEIGHT - ROBOT_RADIUS;
          enemy.vy = -Math.abs(enemy.vy);
      }

      // Update angle to face movement
      if (enemy.vx !== 0 || enemy.vy !== 0) {
          enemy.angle = Math.atan2(enemy.vy, enemy.vx);
      }

      // Collision with player
      const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
      if (dist < ROBOT_RADIUS + ROBOT_RADIUS) { // Robot hits robot
        gameOver();
      }
    });
  }

  function draw() {
    // Clear & Draw Field
    if (fieldImg.complete) {
        ctx.drawImage(fieldImg, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    } else {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    }

    // Draw Artifacts
    artifacts.forEach(a => {
        ctx.save();
        ctx.translate(a.x, a.y);

        ctx.fillStyle = a.color;
        ctx.shadowColor = a.color;
        ctx.shadowBlur = 15;

        ctx.beginPath();
        // Draw centered square
        ctx.rect(-ARTIFACT_RADIUS, -ARTIFACT_RADIUS, ARTIFACT_SIZE, ARTIFACT_SIZE);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
    });

    // Draw Player
    drawRobot(ctx, player.x, player.y, player.angle, false);

    // Draw Enemies
    enemies.forEach(e => {
      drawRobot(ctx, e.x, e.y, e.angle, true);
    });
  }

  function drawRobot(context, x, y, angle, isEnemy) {
    context.save();
    context.translate(x, y);

    // Rotate: image typically points UP (-90 deg). Math angle is 0 at Right.
    // So if angle is 0 (Right), we need to rotate image +90 deg.
    context.rotate(angle + Math.PI / 2);

    if (robotImg.complete) {
        // Draw robot image
        context.drawImage(robotImg, -ROBOT_RADIUS, -ROBOT_RADIUS, ROBOT_SIZE, ROBOT_SIZE);

        // Tint enemies red by drawing a semi-transparent red square over them
        // using source-atop to only tint the non-transparent pixels
        if (isEnemy) {
            context.globalCompositeOperation = 'source-atop';
            context.fillStyle = 'rgba(255, 0, 0, 0.5)';
            context.fillRect(-ROBOT_RADIUS, -ROBOT_RADIUS, ROBOT_SIZE, ROBOT_SIZE);
        }
    } else {
        // Fallback Circle
        context.beginPath();
        context.arc(0, 0, ROBOT_RADIUS, 0, Math.PI * 2);
        context.fillStyle = isEnemy ? 'red' : 'blue';
        context.fill();
    }

    context.restore();
  }

  function gameLoop() {
    if (!isGameRunning) return;
    update();
    draw();
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  function gameOver() {
    isGameRunning = false;
    cancelAnimationFrame(animationFrameId);
    finalScoreElement.textContent = score;
    uiOverlay.classList.remove('hidden');
    gameOverScreen.classList.remove('hidden');
  }

  // Event Listeners
  startBtn.addEventListener('click', initGame);
  restartBtn.addEventListener('click', initGame);

  // Initial Render (background only)
  fieldImg.onload = () => {
      if (!isGameRunning) {
          ctx.drawImage(fieldImg, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      }
  };

</script>
