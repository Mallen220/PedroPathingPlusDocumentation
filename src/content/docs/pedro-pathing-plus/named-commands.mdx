---
title: Named Commands & Events
description: Learn how to use NamedCommands and ProgressTracker to sync robot actions with your path.
---

PedroPathingPlus provides a robust system for synchronizing robot actions with your path traversal. This system bridges the gap between the strings defined in the [Event Markers](/pedro-pathing-plus-visualizer/event-markers) of the Visualizer and the Java code running on your robot.

## Overview

The system consists of two main components:

1.  **`NamedCommands`**: A central registry that maps string names (e.g., "OpenClaw") to executable `Command` objects.
2.  **`ProgressTracker`**: A utility that monitors the robot's progress along the path and automatically triggers these named commands at the correct position.

## Registering Commands

Before your autonomous routine runs, you must register the commands you intend to use. This is typically done in your OpMode's `init()` method or a `RobotContainer` constructor.

```java
import com.pedropathingplus.pathing.NamedCommands;
import com.pedropathingplus.command.InstantCommand;

public void init() {
    // Registering a simple Runnable (wrapped automatically in InstantCommand)
    NamedCommands.registerCommand("OpenClaw", () -> robot.claw.open());

    // Registering a full Command object
    NamedCommands.registerCommand("ScoreSpecimen", new ScoreSpecimenCommand(robot));

    // Registering with a description (useful for debugging)
    NamedCommands.registerCommand("Intake", new IntakeCommand(), "Starts the intake motor");
}
```

### Supported Command Types

The `registerCommand` method is flexible and accepts:
- **`Command` objects**: Standard PedroPathingPlus commands.
- **`Runnable` (Lambdas)**: Automatically wrapped in an `InstantCommand`.
- **Any Object**: Wrapped in a `ReflectiveCommandAdapter` (if it has `initialize`, `execute`, `end`, etc.).

## Using ProgressTracker

The `ProgressTracker` is responsible for "watching" the path follower and firing events.

### 1. Initialization

Create a `ProgressTracker` instance, passing it your `Follower` and (optionally) `Telemetry`.

```java
ProgressTracker progressTracker = new ProgressTracker(follower, telemetry);
```

### 2. Loading Events

When using the **Command-Based** export from the Visualizer, the generated code automatically handles event registration. If you are writing custom code, you can register events manually:

```java
// Register "OpenClaw" to trigger at 50% (0.5) of the path
progressTracker.registerEvent("OpenClaw", 0.5);
```

### 3. Setting the Chain

Whenever you start a new `PathChain`, you must inform the tracker. This resets the internal state and prepares it for the new segment.

```java
progressTracker.setCurrentChain(myPathChain);
```

### 4. Updating

If you are **not** using the `FollowPathCommand` (which handles updates internally via the scheduler if integrated properly, or needs manual calls), you might need to check triggers in your loop.

However, typically the `ProgressTracker` is used within a generated `SequentialCommandGroup` or a custom command structure where checks are performed.

**Note:** If you are using the **Command-Based Export** from the Visualizer, the generated `SequentialCommandGroup` uses `WaitUntilCommand` or similar structures that query `progressTracker.shouldTriggerEvent("Name")`.

```java
// Example usage in generated code:
new WaitUntilCommand(() -> progressTracker.shouldTriggerEvent("OpenClaw")),
new InstantCommand(() -> progressTracker.executeEvent("OpenClaw"))
```

## Manual Execution

You can manually trigger a named command at any time using the tracker. This ensures it only runs once per registration cycle (preventing double-firing).

```java
progressTracker.executeEvent("OpenClaw");
```

## Debugging

You can list all registered commands to the Driver Station telemetry to verify your setup.

```java
NamedCommands.listAllCommands(telemetry);
telemetry.update();
```

This will print a table of Command Name, Class Type, and Description.
