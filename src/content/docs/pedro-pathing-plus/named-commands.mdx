---
title: Named Commands
description: Register and retrieve commands by name for dynamic execution.
---

The `NamedCommands` utility is a powerful feature in Pedro Pathing Plus that allows you to associate string names with command objects. This is particularly useful for triggering commands from external sources, such as path files generated by the Visualizer or custom autonomous scripts.

## Introduction

In many autonomous routines, especially those generated by the [Pedro Pathing Visualizer](/pedro-pathing-plus-visualizer/getting-started/), events are defined by simple text strings (e.g., `"IntakeDeploy"`, `"Shoot"`). The robot needs a way to translate these strings into executable code.

`NamedCommands` acts as a central registry where you can:
1.  **Register** your commands with unique names during initialization.
2.  **Retrieve** and schedule them dynamically during execution.

## Registering Commands

You should register your commands during the initialization phase of your OpMode. This ensures they are available when the path following begins.

### Basic Registration
You can register any class that implements the `Command` interface.

```java
// Assuming 'intake' is your IntakeSubsystem
NamedCommands.registerCommand("IntakeOn", new IntakeOnCommand(intake));
NamedCommands.registerCommand("Shoot", new ShootCommand(shooter));
```

### Functional Registration
You can also register simple actions using `InstantCommand` or lambdas.

```java
// Register a Runnable as an InstantCommand
NamedCommands.registerCommand("OpenClaw", () -> claw.open());

// Register with a description (optional)
NamedCommands.registerCommand("CloseClaw", () -> claw.close(), "Closes the robot claw");
```

## Using Named Commands

Once registered, commands can be retrieved and scheduled by name.

### Manual Execution
If you need to trigger a command based on a string input (e.g., from a telemetry menu or file):

```java
if (NamedCommands.hasCommand("MyCommand")) {
    NamedCommands.getCommand("MyCommand").schedule();
} else {
    telemetry.addData("Error", "Command not found!");
}
```

### Integration with ProgressTracker

The most common use case is within the `ProgressTracker`. When following a path, the tracker can automatically execute named commands at specific waypoints or completion percentages.

```java
// In your OpMode
ProgressTracker tracker = new ProgressTracker(follower, telemetry);

// Register an event to trigger "OpenClaw" at 50% of the path
tracker.registerEvent("OpenClaw", 0.5);

// In your loop
tracker.executeEvent("OpenClaw"); // Will only run if condition is met
```

> **Note:** The `ProgressTracker` internally checks `NamedCommands` to find the command associated with the event name.

## Best Practices

1.  **Clear Registry:** Call `NamedCommands.clearAllCommands()` at the start of your `init()` method or in a `finally` block to ensure a clean state between OpModes.
2.  **Consistent Naming:** Use the exact same names in your Java code as you do in the Visualizer's Event Markers. Case sensitivity matters!
3.  **Descriptions:** Provide descriptions when registering commands to help with debugging. You can list all registered commands using `NamedCommands.listAllCommands(telemetry)`.

## Example OpMode

Here is a complete example of how to set up `NamedCommands` in an autonomous OpMode.

```java
@Autonomous(name = "Named Commands Example")
public class NamedCommandsAuto extends LinearOpMode {

    private Follower follower;
    private ProgressTracker tracker;

    // Subsystems
    private ClawSubsystem claw;

    @Override
    public void runOpMode() {
        // Initialize Hardware
        follower = new Follower(hardwareMap);
        claw = new ClawSubsystem(hardwareMap);
        tracker = new ProgressTracker(follower, telemetry);

        // Clear previous commands
        NamedCommands.clearAllCommands();

        // Register Commands
        NamedCommands.registerCommand("OpenClaw", () -> claw.open());
        NamedCommands.registerCommand("CloseClaw", () -> claw.close());
        NamedCommands.registerCommand("Score", new ScoreCommand(claw));

        // Setup Path and Events
        PathChain path = follower.pathBuilder()
            .addPath(new BezierLine(new Pose(0,0), new Pose(20,20)))
            .setConstantHeadingInterpolation(0)
            .build();

        // Trigger "OpenClaw" at 50% progress
        tracker.setCurrentChain(path);
        tracker.registerEvent("OpenClaw", 0.5);

        waitForStart();

        follower.followPath(path);

        while (opModeIsActive()) {
            follower.update();

            // Check and trigger events
            if (tracker.shouldTriggerEvent("OpenClaw")) {
                tracker.executeEvent("OpenClaw");
            }

            telemetry.update();
        }

        // Cleanup
        NamedCommands.clearAllCommands();
    }
}
```
